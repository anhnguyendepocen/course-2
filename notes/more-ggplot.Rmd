---
title: "More `ggplot2`"
output:
  html_document:
    highlight: pygments
    theme: readable
    toc: yes
    toc_float: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

```{r packages, cache = FALSE, message = FALSE}
library(tidyverse)
library(knitr)
library(broom)
library(forcats)
library(stringr)
library(ggrepel)

library(socviz)

options(digits = 3)
set.seed(1234)

theme_set(theme_minimal())
```

# Group data and the group aesthetic

Lets begin by examining the Gapminder dataset. We want to plot the life expectancy over time for each country in the data. We would map `year` to `x` and `lifeExp` to `y`.

```{r gapminder}
library(gapminder)

ggplot(data = gapminder,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_line()
```

Oops. This is problematic. `ggplot()` did not understand the actual structure of the data. We want one line drawn for every country; instead it drew a single line connecting all the dots. In this case, we should use the `group` aesthetic to tell `ggplot()` explicitly about the country-level structure of the data.

```{r gapminder-country}
ggplot(data = gapminder,
       mapping = aes(x = year,
                     y = lifeExp,
                     group = country)) +
  geom_line()
```

The `group` aesthetic is only necessary if the grouping information is not already contained in the built-in variables being mapped. For instance, if we plot points to `continent` the grouping is already clear.

```{r gapminder-continent}
ggplot(data = gapminder,
       mapping = aes(x = lifeExp,
                     y = gdpPercap,
                     color = continent)) +
  geom_point()

ggplot(data = gapminder,
       mapping = aes(x = lifeExp,
                     y = gdpPercap,
                     color = continent,
                     # redundant
                     group = continent)) +
  geom_point()
```

## Statistical transformations and temporary variables

As we've heard before, `ggplot()` can statistically transform and summarize the underlying data set through the use of `stat_` functions. For example, to add a smoothing line to a plot, we can use `geom_smooth()`:

```{r geom-smooth}
ggplot(data = gapminder,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_line(aes(group = country), alpha = .1) +
  geom_smooth()
```

`geom_smooth()` can generate trend lines using a variety of algorithms: LOESS, OLS, GAM, etc. To identify the specific method we use the `method` argument:

```{r geom-smooth-ols}
ggplot(data = gapminder,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_line(aes(group = country), alpha = .1) +
  geom_smooth(method = "lm")
```

Every `geom_` function uses a default `stat_` function to plot by default. Sometimes these default calculations make inherent sense. Other times they may not be as obvious. For example, consider this graph:

```{r bigregion}
ggplot(data = gss_sm,
            mapping = aes(x = bigregion)) +
  geom_bar()
```

We use a single mapping (`aes(x = bigregion)`). `geom_bar()` automatically counts the number of individual observations in the data set for each region of the United States. But where did the y-axis variable `count` come from? It was calculated by the default `stat_count()` function. This function actually computes two variables, `count` and `prop` (proportion). If we want to draw the chart with relative frequencies, we need to use the `prop` variable.

```{r prop}
ggplot(data = gss_sm,
            mapping = aes(x = bigregion)) +
  geom_bar(aes(y = ..prop..))
```

Since `count` is generated by `stat_count()` and is not stored anywhere in the R session, it is a temporary variable we access within the `ggplot()` call using `..` notation. This avoids confusion if there was a column called `count` or `prop` in `gss_sm`.

Notice the plot does not look correct. The y-axis is accurate, but all the bars have a value of 1. We want them to instead **sum** to 1, representing the number of observations per region as a proportion of all respondents in the data set. This is a type of grouping problem. However it is the opposite from before. Rather than grouping by region, we want to explicitly not group by region. To do that, we map a dummy value to the `group` aesthetic.

```{r prop-correct}
ggplot(data = gss_sm,
            mapping = aes(x = bigregion,
                          group = 1)) +
  geom_bar(aes(y = ..prop..))
```

# Frequency plots

In drawing frequency plots, we can incorporate color through the `fill` aesthetic.

```{r bar-color}
ggplot(data = gss_sm,
       mapping = aes(x = religion,
                     fill = religion)) +
  geom_bar()

ggplot(data = gss_sm,
       mapping = aes(x = religion, fill = religion)) +
  geom_bar() +
  guides(fill = FALSE) 
```

Since we map the same variable to two different aesthetics, we don't really need the legend. We can disable that with `guides(fill = FALSE)`.

## The awkward way

More commonly, we would add color to a bar graph to cross-classify two categorical variables. This is the graphical equivalent of a frequency table. We can do this directly within `ggplot()`, however it is also more convoluted.

Consider examining religious preference by census region.

```{r region-religion}
ggplot(data = gss_sm,
       mapping = aes(x = bigregion,
                     fill = religion)) +
  geom_bar()
```

By default we get a stacked bar chart. If we want to make comparisons easier, we could convert this to a proportional bar chart.

```{r region-religion-fill}
ggplot(data = gss_sm,
       mapping = aes(x = bigregion,
                     fill = religion)) +
  geom_bar(position = "fill")
```

Now all the bars are the same height, but we lost the ability to see the relative size of each region with respect to the overall total. What if we wanted to show the proportion of religions within regions of the country, but instead of stacking the bars we want separate bars? The first attempt may use `position = "dodge"`.

```{r region-religion-dodge}
ggplot(data = gss_sm,
       mapping = aes(x = bigregion,
                     fill = religion)) +
  geom_bar(position = "dodge")
```

Good structure, but we're bach to counts. Let's directly map the `..prop..` variable to the `y` aesthetic as well to preserve the proportion on the y-axis.

```{r region-religion-dodge-prop}
ggplot(data = gss_sm,
       mapping = aes(x = bigregion,
                     fill = religion)) +
  geom_bar(aes(y = ..prop..), position = "dodge")
```

Still not correct. Same problem as before. Each individual bar sums to 1. If we want overall proportions for a single variable, we mapped `group = 1`. What if we do that here but with respect to `religion`?

```{r region-religion-dodge-prop-religion}
ggplot(data = gss_sm,
       mapping = aes(x = bigregion,
                     fill = religion)) +
  geom_bar(aes(y = ..prop..,
               group = religion), position = "dodge")
```

Looks better, but we still have a problem. Bars within a single region do not sum to 1. Instead, bars for any particular region sum to 1.

```{r region-religion-facet}
ggplot(data = gss_sm,
       mapping = aes(x = religion)) +
  geom_bar(aes(y = ..prop..,
               group = bigregion), position = "dodge") +
    facet_wrap(~ bigregion)
```

The easiest approach is to use `facet_wrap()` and not force `geom_bar()` and `stat_count()` to do all the work in a single step. Instead, we can ask `ggplot()` to give us a proportional bar chart of religious affiliation, and then facet that by region. The proportions are calculated within each panel, which is the breakdown we wanted. This has the added advantage of not producing too many bars within each category.

## Calculate manually

Rather than doing all the summarizing in `ggplot()`, we could instead calculate the frequencies and proportions manually using `dplyr` functions first, then use the summarized data frame as the basis for the bar graph.

```{r rel-by-region}
glimpse(gss_sm)

(rel_by_region <- gss_sm %>%
    group_by(bigregion, religion) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N),
           pct = round((freq * 100), 0)))
```

Now this is easy to pass into `ggplot()` and draw the bar graph.

```{r rel-by-region-plot}
ggplot(data = rel_by_region,
       mapping = aes(x = bigregion,
                     y = pct,
                     fill = religion)) +
  geom_col(position = "dodge2") +
  labs(x = "Region", y = "Percent", fill = "Religion") +
  theme(legend.position = "top")
```

Instead of using `geom_bar()`, we use `geom_col()` because we already summarized the data - we want `stat_identity()`, not `stat_count()`. While this figure works, it is not the best we can do. It is generally crowded. Instead, let's convert it to a faceted plot:

```{r rel-by-region-plot-facet}
ggplot(data = rel_by_region,
       mapping = aes(x = religion,
                     y = pct,
                     fill = religion)) +
  geom_col(position = "dodge2") +
  labs(x = "Region", y = "Percent", fill = "Religion") +
  guides(fill = FALSE) + 
  coord_flip() + 
  facet_grid(~ bigregion)
```

# Continuous variables by group or category

```{r}
glimpse(organdata)
```

## Scatterplot

```{r}
ggplot(data = organdata,
            mapping = aes(x = year, y = donors)) +
  geom_point()
```

Not useful.

## Line plots

```{r}
ggplot(data = organdata,
            mapping = aes(x = year, y = donors)) +
  geom_line(aes(group = country)) +
  facet_wrap(~ country)
```

## Boxplots

```{r}
ggplot(data = organdata,
            mapping = aes(x = country, y = donors)) +
  geom_boxplot()
```

Awkward to have country labels on x-axis. Switch to y-axis.

### `coord_flip()`

```{r}
ggplot(data = organdata,
            mapping = aes(x = country, y = donors)) +
  geom_boxplot() +
  coord_flip()
```

### `reorder()`

```{r}
ggplot(data = organdata,
       mapping = aes(x = reorder(country, donors, na.rm = TRUE),
                     y = donors)) +
  geom_boxplot() +
  labs(x = NULL) +
  coord_flip()
```

Add color aesthetic.

```{r}
ggplot(data = organdata,
       mapping = aes(x = reorder(country, donors, na.rm = TRUE),
                     y = donors, fill = world)) +
  geom_boxplot() +
  labs(x = NULL) +
  coord_flip() +
  theme(legend.position = "bottom")
```

### Strip chart

```{r}
ggplot(data = organdata,
       mapping = aes(x = reorder(country, donors, na.rm = TRUE),
                     y = donors, color = world)) +
  geom_point() +
  labs(x = NULL) +
  coord_flip() +
  theme(legend.position = "bottom")
```

Hard to see all the points. Add jitter.

```{r}
ggplot(data = organdata,
       mapping = aes(x = reorder(country, donors, na.rm = TRUE),
                     y = donors, color = world)) +
  geom_jitter() +
  labs(x = NULL) +
  coord_flip() +
  theme(legend.position = "bottom")
```

### Cleveland dotplot

#### Calculate summary statistics

```{r}
(by_country <- organdata %>%
  group_by(consent_law, country) %>%
  summarize(donors_mean= mean(donors, na.rm = TRUE),
            donors_sd = sd(donors, na.rm = TRUE),
            gdp_mean = mean(gdp, na.rm = TRUE),
            health_mean = mean(health, na.rm = TRUE),
            roads_mean = mean(roads, na.rm = TRUE),
            cerebvas_mean = mean(cerebvas, na.rm = TRUE)))
```

Better approach using efficient code.

```{r}
(by_country <- organdata %>%
  group_by(consent_law, country) %>%
  summarize_if(is.numeric, funs(mean, sd), na.rm = TRUE) %>%
  ungroup())
```

#### Draw the plot

```{r}
ggplot(data = by_country,
       mapping = aes(x = donors_mean,
                     y = reorder(country, donors_mean),
                     color = consent_law)) +
  geom_point(size = 3) +
  labs(x = "Donor Procurement Rate",
       y = "", color = "Consent Law") +
  theme(legend.position = "top")
```

#### Use facet instead of color

```{r}
ggplot(data = by_country,
       mapping = aes(x = donors_mean,
                     y = reorder(country, donors_mean))) +
  geom_point(size = 3) +
  facet_wrap(~ consent_law, ncol = 1) +
  labs(x = "Donor Procurement Rate",
       y = "", color = "Consent Law")
```

```{r}
ggplot(data = by_country,
       mapping = aes(x = donors_mean,
                     y = reorder(country, donors_mean))) +
  geom_point(size = 3) +
  facet_wrap(~ consent_law, scales = "free_y", ncol = 1) +
  labs(x = "Donor Procurement Rate",
       y = "", color = "Consent Law")
```

#### Add standard deviation

```{r}
ggplot(data = by_country,
       mapping = aes(x = reorder(country, donors_mean),
                     y = donors_mean)) +
  geom_pointrange(mapping = aes(ymin = donors_mean - donors_sd,
                                ymax = donors_mean + donors_sd)) +
  labs(x = "",
       y = "Donor Procurement Rate") +
  coord_flip()
```

# Plot text directly

## `geom_text()`

```{r}
ggplot(data = by_country,
       mapping = aes(x = roads_mean,
                     y = donors_mean)) +
  geom_point() +
  geom_text(mapping = aes(label = country))
```

```{r}
ggplot(data = by_country,
       mapping = aes(x = roads_mean,
                     y = donors_mean)) +
  geom_point() +
  geom_text(mapping = aes(label = country), hjust = 0)
```

## `ggrepel::geom_text_repel()`

```{r}
elections_historic %>%
  select(2:7)
```

```{r}
p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"

library(ggrepel)

ggplot(elections_historic, aes(x = popular_pct,
                               y = ec_pct,
                               label = winner_label)) +
  geom_hline(yintercept = 0.5, size = 1.4, color = "gray80") +
  geom_vline(xintercept = 0.5, size = 1.4, color = "gray80") +
  geom_point() +
  geom_text_repel() +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
       caption = p_caption)
```

## Label outliers only

```{r}
ggplot(data = by_country,
       mapping = aes(x = gdp_mean, y = health_mean)) +
  geom_point() +
  geom_text_repel(data = filter(by_country, gdp_mean > 25000),
                  mapping = aes(label = country))

ggplot(data = by_country,
       mapping = aes(x = gdp_mean, y = health_mean)) +
  geom_point() +
  geom_text_repel(data = filter(by_country,
                                gdp_mean > 25000 | health_mean < 1500 |
                                  country %in% "Belgium"),
                  mapping = aes(label = country))
```

# Session Info {.toc-ignore}

```{r cache = FALSE}
devtools::session_info()
```








